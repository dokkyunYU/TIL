# 객체 지향 프로그래밍

객체는 기존 절차지향 프로그래밍의 불편함을 해결하기 위해 나왔다.

절차지향 프로그래밍은 원하는 내용을 구현할 수 있는 기능에 초점을 맞춘다면, 객체지향 프로그래밍은 구조적 기능성에 초점을 맞춘다.

객체지향적 프로그래밍은 절차지향적 프로그래밍에 비해 그 프로그램의 확장성에 큰 도움을 준다.

객체란 정보(데이터)와 행위(연산, 처리)를 가지는 컴퓨터 메모리 내의 실체를 말한다.
- 객체에는 역할, 책임, 협력의 세가지 속성을 가진다.


## 객체의 주요한 4가지 요소

1. 추상화 : 불필요한 세부 사항은 감추고 필요한 부분만 드러낸다. (객체뿐만 아니라 컴퓨터 공학 전체를 관통하는 핵심적 요소)
2. 캡슐화 : 어느 객체 내부의 내용을 외부에서 함부로 조작할 수 없도록 만든다.
3. 다형성 : 같은 메서드가 클래스에 따라서 다른 내용을 가질 수 있다.
4. 상속 : 다른 클래스의 내용을 참조하는 것을 통해 자신의 클래스 내용을 구성할 수 있고, 일부는 변경하는 것도 가능하다.


### 추상화

내가 특정한 값을 집어넣었을때, 내부에 어떤 일이 일어나는지 알 필요 없이, 원하는 결과를 도출(반환)받는것이 중요한 것이며 이것이 추상화의 개념이다.

함수의 내부 내용을 알지 못해도 어떤 데이터를 넣었을때 어떤 결과값을 받을 수 있는지만 알 수 있으면 되는 것과 같다.


## 클래스

클래스는 일종의 설계도이며 이 설계도를 통해 만들어낸 각각의 객체를 인스턴스라고 한다. (a = list('abc')) 일때 a는 리스트라는 클래스의 인스턴스이다.


### 속성

특정 데이터 타입 혹은 클래스의 객체들이 가지게 될 상태/데이터를 의미한다.

클래스 변수와 인스턴스 변수가 존재한다.

- 클래스 변수 : 클래스 자체에 존재하여 해당 클래스를 통해 생성된 모든 인스턴스 객체들이 공유하여 접근가능한 변수

- 인스턴스 변수 : 각 인스턴스 객체 내부에서만 존재하고 접근할 수 있는 변수

### 인스턴스와 클래스간의 이름공간

- 클래스를 정의하면 클래스에 해당하는 이름공간이 생성된다.

- 인스턴스를 생성하면 인스턴스 객체가 생성되고 그에 해당하는 이름공간이 생성된다.

- 각 인스턴스 객체에서 특정한 데이터에 접근하면 우선 인스턴스 내부에서 찾고, 이후에는 클래스에서 찾는다.


### 메서드

클래스를 기반으로 생성된 객체들에서 공통적으로 사용 가능한 행위(함수)

#### 생성자 __init__

클래스에 의해 각 인스턴스가 생성될때 자동으로 호출되는 메서드를 의미한다.

인스턴스 객체의 초기값을 설정한다. (Initializing)

```python
def __init__(self,*args)
```


#### 매직 메서드

언더바 2개로 감싸여진 __메서드__들을 의미한다.

__str__ : 인스턴스 객체가 print에 의해 출력 되었을때 해당 인스턴스 객체를 문자열로 표현할 내용을 정의한다.
(print 함수는 기본적으로 받은 argument들을 전부 str화 해서 출력한다.)

```python
def __str__(self):
  return str
```

__add__ : 인스턴스 객체가 더하기 상호작용의 대상으로써 사용되었을때 어떤식의 형태를 취하여 어떤 결과를 내놓을 것인지를 정의한다.

```python
def __add__(self, other):
  return self.method() + other.method() || self.variable + other.variable
```

__del__ : 소멸자. 인스턴스 객체가 소멸되기 직전에 호출되는 메서드이다. (del 인스턴스_이름 으로 변수가 가지고 있는 객체를 가리키는 참조값을 없앨 수 있다. 이 경우 객체는 사라지지 않지만, 만약 이 행위 결과로 어떠한 변수도 더이상 그 객체를 가리키지 않게 되면 그때 객체는 소멸한다.) (프로그램이 끝날때에도 모든 객체가 소멸하기 때문에 소멸자가 호출된다.)

```python
def __del__(self):
  pass
```


### 클래스 메서드

클래스가 사용할 메서드로서 클래스 변수에 접근하여 연산 및 처리와 변경을 수행할 때 사용된다.

@classmethod 데코레이터를 사용하여 정의한다.

호출시 첫번째 인자로 클래스cls가 전달된다.

```python
class some_class :
  class_variable1 = 0
  @classmethod
  def method_name(cls, *args):
    cls.class_variable1 += 1
```

### 스태틱 메서드

인스턴스 메서드에서 그 인스턴스 변수에 접근하려면 self를 parameter로 포함해 놓아야 self.variable_name의 방식을 통해 인스턴스 변수에 접근할 수 있다.
그런데 인스턴스 변수에 접근할 필요가 없는 고정 데이터값을 사용하거나 반환하는 메서드라면 굳이 이렇게 할 필요가 없으므로 스태틱 메서드를 정의한다.

```python
@staticmethod
def method_name(*args):
  pass
```

### 메서드 오버라이딩

상속받은 메서드를 재정의하여 그 클래스만의 메서드로 수정할 수 있다.

부모 클래스의 메서드를 사용하고 싶은 경우 super().method_name를 사용한다.

스태틱 메서드도 오버라이딩 된다. dir(class_name)을 하면 그 클래스 내부 요소의 목록을 반환받을 수 있다.

스태틱 메서드에서는 super()를 사용할 수 없다. super()는 메서드 내에서 parameter로 받은 self 혹은 cls를 소괄호 내부로 대입하여 그 상위 클래스를 참조할 수 있게하는데, 스태틱 메서드는 인스턴스 객체 혹은 클래스를 가리키는 어떤 변수도 parameter로 받지 않기 때문에 사용할 수 없다.


## 파이썬의 모든것은 객체

리스트가 컨테이너이며 시퀀스 자료형이라는 말은 컨테이너 클래스를 상속받은 시퀀스자료형 클래스를 다시 상속받아 만들어진 클래스라는 것을 의미한다.
issubclass(list, Container) == True

이것을 알지 못해도 얼마든지 리스트를 사용할 수 있는데 이것 역시 추상화이다.



## 캡슐화


### public member

쉽게 객체 밖에서도 접근할 수 있는 변수

class_name.member_name

### protected member

언더바 1개로 시작하는 메서드나 속성

암묵적 규칙에 의해 부모 클래스 내부의 자식클래스에서만 호출 가능

하위 클래스 오버라이딩 허용

class_name._member_name

### private member

언더바 2개로 시작하는 메서드나 속성

본 클래스 내부에서만 사용이 가능

하위 클래스 상속 및 호출 불가능(오류)

외부 호출 불가능(오류) : 내부적으로 이름을 instance_name._class_name__member_name으로 바꿔버리기에 그대로 접근 불가. 만약 class_name까지 알고 있으면 접근은 가능하지만 하지 않는다.

class_name.__member_name


#### 접근제어자

##### getter

클래스 내부에 이러한 private한 member값을 반환하는 메서드를 만들어서, 외부에서 그 객체에게 메서드 호출 요청을 통하여 값을 받는 것

#### setter

클래스 내부에 member값을 설정하는 메서드를 만들어서, 외부에서 그 객체에게 메서드 호출 요청을 통하여 값을 설정하는것

#### @property

```python
@property
def age(self):
  return self._age

@age.setter
def age(self, new_age):
  if 조건:
    raise (ValueError, 에러종류) '~~~~~'
    return
  return self._age = new_age # if에 걸리지 않을경우
```